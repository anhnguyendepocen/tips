---
title: "ggplot2 Use Cases"
author: "J. R. Minter"
date: "Started: 2016-01-20, Last modified: 2018-06-28"
output:
  html_document:
    csl: ../inc/american-chemical-society-with-titles-sentence-case-doi.csl
    css: ../theme/jm-gray-vignette.css
    toc: true
    number_sections: yes
bibliography: ../inc/tips.bib
---

[Back to Index](../README.html)

This is a work in progress.

# Capture thoughts for enhancements at the top...

## Make it easy to comment out parts

From [Wei Yang Tham](https://twitter.com/wytham88/status/1012085073368272903)

> One of my favorite ggplot2 tricks, which I learned on the
> `@R4DScommunity` Slack group: add `NULL` to the end of your ggplot
> chain so you can comment out a command without ending with a `+`.

His example had problems, so I made one based on 
[this](http://www.sthda.com/english/wiki/ggplot2-density-plot-quick-start-guide-r-software-and-data-visualization) example.

```{r endWithANull, fig.width=9.5}
library(ggplot2)
set.seed(42)
df <- data.frame(gender = factor(rep(c("F", "M"), each = 200)),
                 weight = round(c(rnorm(200, mean = 55, sd=5),
                                  rnorm(200, mean = 65, sd=5))))

plt <- ggplot(df, aes(x=weight, fill=gender)) +
       geom_density(alpha=0.5) +
       geom_hline(yintercept = 0, colour='white') +
       ggtitle("Weight as a function of gender") +
       theme(axis.text=element_text(size=12),
             axis.title=element_text(size=12),
             plot.title=element_text(hjust = 0.5)) +
       # geom_histogram() +
       NULL
print(plt)
```



## Designing conceptual plots

This [example](https://github.com/andrewheiss/supply-demand-ggplot) by Andrew Heiss is excellent!

## Adding functions

This is a work in progress. Some resources for later

[R-Studio example](http://rstudio-pubs-static.s3.amazonaws.com/3365_9573f6d661b444499365fe1841ee65d3.html)

[t-redactyl.io](http://t-redactyl.io/blog/2016/03/creating-plots-in-r-using-ggplot2-part-9-function-plots.html)


# Rationale for this document

I typically have spurts where I use  R and ggplot2 [@Wickham2009a] to 
analyze data and find myself saying, "I've done this before, but where
is the code?" These exemplars should make it easy to get back up to speed
quickly. As Karl Broman noted: 

> Your closest collaborator is you six months ago and you don't respond to email!

So this is for "future me" and anybody else who needs it. See also the
**ggplotExamples** project in your private jrm-solutions repo.

Also note [this](https://martinsbioblogg.wordpress.com/2017/04/23/using-r-a-function-that-adds-multiple-ggplot2-layers/) recent helpful example.

Now get started

First, let's load the packages we need.

```{r, message=FALSE}
library(tidyverse)
library(latex2exp)
library(pander)
library(here)
```

**Note:** For pander options see [rapporter.github.io](http://rapporter.github.io/pander/#pander-options).

# Plot time dependent data

This group of examples comes from 
[www.statworx.com](https://www.statworx.com/de/blog/customizing-time-and-date-scales-in-ggplot2/).

## Base plot

We are using ggplot's **economics** data set. Our base plot looks like
this:


```{r ggplotDate, fig.width=9.5}
library(ggplot2)

base_plot <- ggplot(data = economics) +
             geom_line(aes(x = date, y = unemploy),
                       color = "#09557f", alpha = 0.6, size = 0.6) +
             labs(x = "Date", y = "US Unemployed in Thousands",
             title = "Base Plot") +
             theme_minimal()
print(base_plot)
```

## Scale types

As of now, `ggplot2` supports three date and time classes: `POSIXct`,
`Date` and `hms`.

Depending on the class at hand, axis ticks and labels can be controlled
by using `scale_*_date`, `scale_*_datetime` or `scale_*_time`,
respectively. Depending on whether `scale_x_*` or not, it is
`scale_y_*` to be used in a job. For the sake of simplicity, the
examples only `scale_x_date` are used, but all are the same.

## Minor Modification 1

Let's start easy. With the argument limitsthe range of the displayed
dates or time can be set. Two values of the correct date or time.

```{r pltMod1, fig.width=9.5, message=FALSE, error=FALSE}
plt_mod1 <- base_plot +
            scale_x_date(limits = as.Date(c("1980-01-01", "2000-01-01"))) +
            ggtitle("limits = as.Date(c(\"1980-01-01\", \"2000-01-01\"))")

print(plt_mod1)
```

The `expand`argument ensures there is some distance between the
displayed data and the axes. The argument `expand`takes two numeric
values, the first is the multiplicative expansion constant. The larger
one of the two distances is employed in the plot, the multiplied
constant is multiplied by the range of the displayed data. The resulting
empty space is at the left and right end of the x-axis or the top and
bottom of the y-axis.

The `position`argument defines where the labels are displayed:
Either "left" or "right" from the y-axis or on the "top" or
"bottom" from the x-axis.

## Axis Ticks and Grid Lines

More essential than the cosmetic modifications. There are several ways
to define the axis of ticks of dates and times. There are the labeled
major breaks and the minor breaks , which are labeled but marked by
grid lines. These can be customized with the arguments `breaks` and
`minor_breaks`, respectively. The `breaks` as the well as `minor_breaks`
can be defined by a numeric vector of exact positions or a function
with the axis limits as inputs and breaks as outputs. Alternatively,
the arguments may be `NULL` different.

```{r pltMod2, fig.width=9.5}
plt_mod2 <- base_plot +
            scale_x_date(expand = c(0, 5000)) + #5000/365 = 13.69863 years
            ggtitle("expand = c(0, 5000)")
      
print(plt_mod2)
```

Furthermore and very conveniently, the format of the labels can be
controlled by the following `date_labels`. Note how the example
**sets the default table alignment...**


```{r readDataTD}
fi <- here('ggplot2UseCases/dat/csv/date-time-codes.csv')
panderOptions('table.alignment.default','left')
df <- read.csv(fi)
pander(df)
```

## Plot with modified time breaks

```{r pltMod3, fig.width=9.5}
plt_mod3 <- base_plot +
            scale_x_date(date_breaks = "10 years",
                         date_minor_breaks = "2 years") +
            ggtitle("date_(minor_)breaks = \"x years\"")
print(plt_mod3)
```

```{r pltMod4, fig.width=9.5}
plt_mod4 <- base_plot +
            scale_x_date(date_labels = "%Y (%b)") +
            ggtitle("date_labels = \"%Y (%b)\"") 
print(plt_mod4)
```

# Box Plot with different factors

## Read and process the data

First we read the data and process into tidy form.
See the `tidyData` tip for a detailed explanation.

```{r readCycler, comment=NA}
fi <- here("tidyData/dat/CyclerCPK.csv")
df <- read.csv(fi, header=TRUE)
names(df) <- c("Subject","Age","Gender","TRT",
         "CPK.1", "CPK.2", "CPK.3", "CPK.4")
dfTidy <-  df %>%
           gather(replicate, CPK, CPK.1:CPK.4)

extractReplicate <- function(x){
  unlist(as.integer(unlist(strsplit(x, "[.]"))[2]))
}
test <- unlist(lapply(dfTidy$replicate,extractReplicate))
dfTidy$replicate = as.factor(test)
summary(dfTidy)
```

## Make the plot

```{r ggplotSeries}
cyclerPlt <- ggplot(dfTidy, aes(x=TRT, y=CPK, fill=Gender)) +
             geom_boxplot() +
             xlab("Treatment Level") +
             ggtitle("CPK as a function of treatment and gender") +
             theme(axis.text=element_text(size=12),
                   axis.title=element_text(size=12),
                   plot.title=element_text(hjust = 0.5)) # center the title...

print(cyclerPlt)

```


# Plot series from different dataframes

Generally, ggplot2 examples show how to plot different series
by melting a data frame. This is problematic when our X and
Y values are on differen scales. Here is an example from some
CASINO data.

## Step 1: Load the data


```{r}
fi <-'./dat/csv/20nm-C-10nm-Ag-On-SiO2-5kV.csv'
df10 <- read.csv(fi, header=TRUE, as.is=TRUE)
panderOptions('table.alignment.default',
               function(df) ifelse(sapply(df, is.numeric), 'right', 'left'))
pander(head(df10))
```


```{r}
fi <-'./dat/csv/20nm-C-30nm-Ag-On-SiO2-5kV.csv'
df30 <- read.csv(fi, header=TRUE, as.is=TRUE)
panderOptions('table.alignment.default',
              function(df) ifelse(sapply(df, is.numeric), 'right', 'left'))
pander(head(df30))
```

Note that these have different X-axis scalings. I will also try to
scale the data by the ratio of the BSE coefficients (the data ie
reported as **normalized hits** so the sum of the BSE = 1.0). Note
how the data series are specified from different dataframes...


```{r}

scale = 0.300835/0.190755

plt <-  ggplot() +
        geom_point(data=df10, aes(x=Z.nm, y=Hits),
                   colour="darkblue") +
        geom_point(data=df30, aes(x=Z.nm, y=scale*Hits),
                   colour="red") +
        xlab("Depth [nm]") +
        ylab("BSE hits") +
        scale_x_continuous(breaks = seq(from = 0, to = 150, by = 25),
                           limits = c(0,150)) +
        scale_y_continuous(breaks = seq(from = 0, to = 0.030, by = 0.005),
                           limits = c(0,0.030)) +
        ggtitle("Monte Carlo model of C-coated Ag on glass at 5 kV") +
        theme(axis.text=element_text(size=12),
              axis.title=element_text(size=12),
              plot.title=element_text(hjust = 0.5)) # center the title

print(plt)
```


# Plot/Fit Coulter Data

## Set packages and limits

```{r, setLimits, warning=FALSE}
library(ggplot2)
library(pander)

xMaxLim   <- 16
yMaxLim   <- 3000
xPredStep <- 0.02
deltaX    <- 2
deltaY    <- 1000
savPlt    <- FALSE
lSize     <- 1
```

## Load data


```{r, LoadCoulterData}
fi <- './dat/csv/sample-1.csv'
df1 <- read.csv(fi, header = TRUE, as.is=TRUE)
fi <- './dat/csv/sample-2.csv'
df2 <- read.csv(fi, header = TRUE, as.is=TRUE)
```

## Fit the Sample 1 data to a Gaussian and calculate a prediction

```{r, fitCoulterS1}
res1 <- nls(cts ~ k*exp(-1/2*(um-mu)^2/sigma^2),
            start=c(mu=5,sigma=5,k=1000), data = df1)

um <- seq(from=0.0, to=xMaxLim, by=xPredStep)
df1P <- data.frame(um=um)
df1P$cts <- predict(res1, newdat=df1P)
```

## Look at the results of the fit

```{r, fitCoulterS1summary}

v1 <- summary(res1)$parameters[,"Estimate"]
pander(v1)
```

## Fit the Sample 2 data to a Gaussian and calculate a prediction

```{r, fitCoulterS2}
res2 <- nls(cts ~ k*exp(-1/2*(um-mu)^2/sigma^2),
            start=c(mu=5,sigma=5,k=1000), data = df2)

um <- seq(from=0.0, to=xMaxLim, by=xPredStep)
df2P <- data.frame(um=um)
df2P$cts <- predict(res2, newdat=df2P)
```

## Look at the results of the fit

```{r, fitCoulterS2summary}
v2 <- summary(res2)$parameters[,"Estimate"]
pander(v2)
```

## Make a plot

```{r, makeCoulterPlot, warning=FALSE}
maxCts = max(df1$cts, df2$cts)

plt <-  ggplot() +
        geom_point(data=df1, aes(x=um, y=cts),  colour="darkblue") +
        geom_line(data=df1P, aes(x=um, y=cts),
                  colour='darkblue', size=lSize) +
        geom_point(data=df2, aes(x=um, y=cts),  colour="red") +
        geom_line(data=df2P, aes(x=um, y=cts),
                  colour='red', size=lSize) +
        xlab("size [microns]") +
        ylab("counts") +
        scale_x_continuous(breaks = seq(from = 1, to = xMaxLim, by = deltaX),
                           limits = c(1, xMaxLim)) +
        scale_y_continuous(breaks = seq(from = 0, to = yMaxLim, by = deltaY),
                           limits = c(0, yMaxLim)) +
        ggtitle("Particle Size (Coulter)") +
        annotate("text", label = 'Sample 1', x = 13, y = 2800, size = 5, colour = "darkblue") +
        annotate("text", label = 'Sample 2', x = 13, y = 2500, size = 5, colour = "red") +
        annotate("text", label = 'credit: Coworker', x = 15, y = 200, size = 3, colour = "black") +
        theme(axis.text=element_text(size=12),
              axis.title=element_text(size=12),
              plot.title=element_text(hjust = 0.5)) # center the title
print(plt)
```


# Plot/fit data from processing EDS spectra

In this case the spectra were simulated using DTSA-II [@Ritchie2011b].

## Step 1: Load the data

```{r}
fi <-'./dat/csv/C-ctd-Si-5-kV-10000-Traj.csv'
df <- read.csv(fi, header=TRUE, as.is=TRUE)
panderOptions('table.alignment.default',
              function(df) ifelse(sapply(df, is.numeric), 'right', 'left'))
pander(head(df))
```

## Compute the C/Si peak ratio and uncertainty

```{r}
df$c.to.si.mu  <-  df$C.Int.mu / df$Si.Int.mu
df$c.to.si.unc <-  sqrt((df$C.Int.unc/df$C.Int.mu)**2 + 
                        (df$Si.Int.unc/df$Si.Int.mu)**2)
```

## Make our plot

```{r}
ctosiInt <-  ggplot(df, aes(x=t.C.nm, y=c.to.si.mu)) +
             geom_errorbar(aes(ymin=c.to.si.mu - 1.96*c.to.si.unc,
                           ymax=c.to.si.mu + 1.96*c.to.si.unc), width=.1) +
             stat_smooth(method = "loess") +
             annotate("text", label = 'loess smooth', x = 70, y = 1.1,
                      size = 5, colour = "blue") +
             geom_point(color='black', size=2) +
             xlab("C thickness [nm]") +
             ylab("C-K/Si-K X-ray intensity ratio") +
             ggtitle("Monte Carlo Model of C-coatings on Si at 5 kV") +
             theme(axis.text=element_text(size=12),
                   axis.title=element_text(size=14),
                   plot.title = element_text(hjust = 0.5)) # center the title
print(ctosiInt)
```

## Step 2: Compute LOESS interpolated predicted values

```{r}
t.C.nm <- seq(from=0.5, to=100, by=0.5)
df2P <- data.frame(t.C.nm=t.C.nm, c.to.si.mu=t.C.nm)
df2P$c.to.si.mu <- predict(loess(c.to.si.mu~t.C.nm, data=df2P))
```

## Step 3: Write some output

```{r}

fi <- './dat/pdf/c-ctd-si-series-plt-5kV.pdf'
ggsave(ctosiInt, file=fi, width=9.0, height=6.0, units="in", dpi=300)

fi <- './dat/png/c-ctd-si-series-plt-5kV.png'

# we want the png to be close to 1024x768...
ggsave(ctosiInt, file=fi, width=9.0, height=6.0, units="in", dpi=113.7778)
fi <- './dat/csv/c-ctd-si-loess-pred-5kV.csv'
write.csv(df2, file=fi, row.names=FALSE)

```

# Plotting PhiRhoZ curves from DTSA-II Monte Carlo simulations

DTSA-II computes the PhiRhoZ curves proposed by [@Packwood1981a].

## Step 1: Load the data.

Use the helper function from package **rEDS** to load the data and explore
the columns. This needs version **0.0.1.1** or later. Note: the **PhiRhoZ.csv**
file outputted by DTSA-II is really **tab-delimited** and has two header
lines (the headers we want and a second units line.) The **rEDS** package
contains a wrapper function (**prepDataframeDtsaPhiRhoZ**) that cleans
the data up and generates a dataframe from which we can choose the 
features that we really want to plot.

```{r, doRead,message=FALSE}
library(rEDS)
panderOptions('round', 3)
inDir <- './dat/csv/'
df <- prepDataframeDtsaMcPhiRhoZ(inDir)
pander(head(df))    
```


## Step 2: Make a dataframe with the transitions we care about.

While we are at it, let's change the dataframe headers to make
it easier to make the plots... We are plotting the generated
and emitted X-rays. Let's make simple mnemonics... 

```{r makeVecs}
                     
z <- df[,1]
okgen <- df[,8]
okemi  <- df[,9]
sikgen <- df[,12]
sikemi  <- df[,13]

df2 <- data.frame(Z.um=z,
                  O.Gen=okgen, O.Emi=okemi,
                  Si.Gen=sikgen, Si.Emi=sikemi)
pander(head(df2))
```

Isn't that more readable! 

In this case we also want to remove the first line because it is the thin
C coating that creates a discontinuity. If we remove this first line,
the smooth works better...

```{r removeStep, message=FALSE}
df3 <- df2[-1, ]
rownames(df3) <- NULL

pander(head(df3))
```

## Step 3: Plot the Si data.

Note the use of the Unicode in the **xlab** string to create the mu...


```{r plotSi, message=FALSE, warning=FALSE}
library(ggplot2)

span <- 0.25

plt <-  ggplot(df3, aes(x = Z.um)) +
        geom_point(aes(y = Si.Gen), colour="blue") +
        geom_smooth(aes(x= Z.um, y=Si.Gen), span = span, color = 'blue') +
        annotate("text", label = 'Generated Si K-L3', x = .8, y = 1.75,
                 size = 5, colour = "blue") +
        geom_point(aes(y = Si.Emi), colour="red") +
        geom_smooth(aes(x= Z.um, y=Si.Emi), span = span, color='red') +
        annotate("text", label = 'Emitted', x = .3, y = .75, size = 5,
                 colour = "red") +
        ylab(label="\U03D5(\U03C1z)") + # note the Unicode string for mu
        xlab("depth [\U00B5m]") +
        ggtitle("DTSA-II Monte Carlo \U03D5(\U03C1z) Model 10 nm C on silica at 10 kV") +
        scale_x_continuous(breaks = seq(from = 0, to = 1, by = 0.25), limits = c(0,1)) +
        scale_y_continuous(breaks = seq(from = 0, to = 2, by = 0.5), limits = c(0,2)) +
        theme(axis.text=element_text(size=12),
              axis.title=element_text(size=14),
              plot.title = element_text(hjust = 0.5)) # center the title
print(plt)
```

## Step 4: Plot the O data.


```{r plotO, message=FALSE, warning=FALSE}

span <- 0.25
df3 <- df2[-1, ]
rownames(df3) <- NULL

plt <-  ggplot(df3, aes(x = Z.um)) +
        geom_point(aes(y = O.Gen), colour="blue") +
        geom_smooth(aes(x= Z.um, y=O.Gen), span = span, color = 'blue') +
        annotate("text", label = 'Generated O K-L3', x = .8, y = 2.25, size = 5, colour = "blue") +
        geom_point(aes(y = O.Emi), colour="red") +
        geom_smooth(aes(x= Z.um, y=O.Emi), span = span, color='red') +
        annotate("text", label = 'Emitted', x = .3, y = .75, size = 5, colour = "red") +
        ylab(label="\U03D5(\U03C1z)") + # note the Unicode string for mu
        xlab("depth [\U00B5m]") +
        ggtitle("DTSA-II Monte Carlo \U03D5(\U03C1z) Model 10 nm C on silica at 10 kV") +
        scale_x_continuous(breaks = seq(from = 0, to = 1, by = 0.25), limits = c(0,1)) +
        scale_y_continuous(breaks = seq(from = 0, to = 2.5, by = 0.5), limits = c(0,2.5)) +
        theme(axis.text=element_text(size=12), axis.title=element_text(size=14),
              plot.title = element_text(hjust = 0.5)) # center the title
print(plt)
```



# Analyze particle size and shape data

## Step 1: Load the data

Load the data from a **.csv** file and decide if we want to save plots.

```{r, results='asis'}
grains <- read.csv("./dat/csv/grains.csv", header = TRUE, as.is=TRUE)
print(names(grains))
bSave <- FALSE
```

## Step 2: Making a Histogram With ggplot2

You have two options to make a histogram with ``ggplot2`` package. You can either use the ``qplot()`` function, which looks very much like the ``hist()`` function:

```{r}
pHD <- ggplot(grains, aes(ecd.nm)) +
       geom_histogram(binwidth = 5) +
       ggtitle("Grain Equivalent Circular Diameter") +
       theme(plot.title = element_text(lineheight=2, size=12)) +
       labs(x="diameter (nm)", y="Count") 

if (bSave == TRUE) {
  ggsave("./dat/png/grain-ecd-histo.png", plot=pHistoAgxDiam,
         width=6, height=4, units="in", dpi=150)
}
print(pHD)
```

## Step 3: Make a histogram for aspect ratio.


```{r}
print(summary(grains$a.r))

pHAR <-  ggplot(grains, aes(a.r)) +
         geom_histogram(bins=50) +
         ggtitle("Grain Aspect Ratio") +
         theme(plot.title = element_text(lineheight=2, size=12)) +
         labs(x="diameter (nm)", y="Count") 
if (bSave == TRUE) {
  ggsave("./dat/png/grain-ecd-histo.png", plot=pHistoAgxAr,
          width=6, height=4, units="in", dpi=150)
}
print(pHAR)
```

## Step 4: Make some classes and plot.

```{r}
equiAxial <- grains$ecd.nm[grains$a.r < 1.05]
elongated <- grains$ecd.nm[grains$a.r >= 1.05]
df1 <- data.frame(ecd=equiAxial,shape='equiaxial')
df2 <- data.frame(ecd=elongated,shape='elonganted')
shapes <- rbind(df1,df2)
rm(df1, df2)

pBPECDAR <- ggplot(shapes, aes(x=shape, y=ecd)) +
            geom_boxplot(aes(fill = shape)) +
            labs("equivalent circular diameter (nm)") 

if (bSave == TRUE) {
  ggsave("./dat/png/grain-ecd-shape-boxplot.png", plot=pBPECDAR,
         width=6, height=4, units="in", dpi=150)
}
print(pBPECDAR)
```

## Step 5: Make a scatter plot.


```{r}
pSPECDAR <- ggplot(grains, aes(x=a.r, y=ecd.nm)) +
            geom_point(colour="blue") +
            labs(x="aspect ratio", y="ecd [nm]") 
if (bSave == TRUE) {
  ggsave("./dat/png/grain-ecd-ar.png", plot=pSPECDAR,
         width=6, height=4, units="in", dpi=150)
}
print(pSPECDAR)
```

```{r}
pSPCECD <- ggplot(grains, aes(x=circ, y=ecd.nm)) +
           geom_point(colour="blue") +
           labs(x="circularity", y="ecd [nm]") 
if (bSave == TRUE) {
  ggsave("./dat/png/grain-ecd-circ.png", plot=pSPCECD,
         width=6, height=4, units="in", dpi=150)
}
print(pSPCECD)
```

## Step 6: Plot the diameter distribution of our dominant morphology.

```{r}
dominant <- grains[grains$a.r <= 1.2, ]
dominant <- dominant[dominant$circ >= 0.8, ]

ecd.mu <- mean(dominant$ecd.nm)
ecd.sd <- sd(dominant$ecd.nm)


pDGD <- ggplot(dominant, aes(ecd.nm)) +
        geom_histogram(binwidth = 5) +
        ggtitle("Dominant Population Equivalent Circular Diameter") +
        theme(plot.title = element_text(lineheight=2, size=12)) +
        labs(x="diameter (nm)", y="Count") 

if (bSave == TRUE) {
  ggsave("./dat/png/dom-grain-ecd-histo.png", plot=pDGD,
         width=6, height=4, units="in", dpi=150)
}
print(pDGD)
```

## Step 7: Make a plot of computed Gaussian data.

```{r}

ecd <- rnorm(100000, mean=ecd.mu, sd=ecd.sd)
df <- data.frame(ecd=ecd)
theoHistPlot <- ggplot(df, aes(ecd)) +
                geom_histogram(binwidth = .1) +
                labs(x="diameter (nm)", y="Count") 

print(theoHistPlot)
```

[Back to Index](../README.html)

## References