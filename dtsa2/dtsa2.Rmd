---
title: "Tips on Using DTSA-II"
author: "J. R. Minter"
date: "Started: 2015-05-19, Last modified: 2018-10-11"
output:
  html_document:
    css: ../theme/jm-gray-vignette.css
    number_sections: yes
    toc: yes
    toc_depth: 3
---

[Back to Index](../README.html)

Note that Nicholas Ritchie has released some helpful videos on
[YouTube](https://www.youtube.com/channel/UCt4nKyhfFQ8xecHyuTnCvIA).
He tries to put out a new release yearly and bug-fix releases as
needed.

# Key tricks

## Notes from Nicholas Ritchie's videos

- **The mouse wheel** zooms in and out on intensity. Can also click and
drag by the counts on the left side.

- **Right mouse button** - displays a context sensitive menu with helpful
tools or options to set. Can also copy status text to the clipboard
from this menu. Can select how lines are labeled. IUPAC is preferred
or element abbreviation for an uncluttered look.

- **Copy as bitmap** produces a high resolution bitmap. Scaling is a bit
counterintuitive. Lettering size is a function of size on the screen.
N. Ritchie typically drags window to 800x250 pixels. On the Mac I can't
get below 270, so I tried 900x300.

- **When using the material editor**, start with a throw-away name like
"Unknown" to prevent overwriting something in the database by accident.
This permits storage and re-use. A good name begins with a letter and
has only letters and numbers. Do not use spaces or odd characters like
`+` or `-` because they can be interpreted as a formulas or sum of
fractions.    
    
    We can type `SiO2` and it will parse the formula. Then all we need
    do is add the density. Be **careful** with capitalization. Only
    capitalize the first letter of each element's abbreviation or you
    will get unexpected results. It can parse the formula for
    fluoroapatite (`Ca5(PO4)3F`). It will also parse sums of mass
    fractions....    
    
    We can also do oxide fractions like this for eagleXG:

  ```
  0.6447825*SiO2+0.1702057*Al2O3+0.1051482*B2O3+0.0542376*CaO+0.0128153*MgO+0.0082368*SrO+0.0015215*SnO2+0.0012188*BaO+0.0005078*Fe2O3+0.0004635*Sb2O3+0.0003145*As2O3+0.0002938*ZrO2+0.0002540*TiO2
  ```
Type the string above into the empty dialog and press "add". We can then
add the density (2.36) and change the name to '**EagleXG**' and save the
results.


- **There are two "Composition" values**. There is the accepted or
standard value that we enter through the material editor and the measured 
composition from spectra.

- **Spectra list** also has a context-sensitive menu accessed by right click

- **The Report tab** has summary of the experiment. Because it is HTML it
is search-able using the OS. The Report menu has a "Report Note" button
that lets the user add comments or notes to the report. One can also add the 
spectrum display to the report. I find it helpful to type the comments in a
text editor with a spell checker before entering into the report. DTSA's report
functions are looking more favorable each time I use them. **To do:** Consider
what best practices would look like in syncing these between computers. It
also looks like DTSA overwrites the report each time. Too bad because one
cannot keep it open in an editor with a spell checker and have it correct
spelling.

- **The command line** is useful for repetitive tasks. The `tabulate()`
function is helpful. For example, one might select a range of values
and enter

  ```
  tabulate(selected())
  ```

  and then copy the results to the clipboard to go into Excel or
a Rmarkdown table.

- **Entering the detector parameters** permits us to simulate
**dose-correct** spectra. One can also tune the parameters by
running a series of simulations. The manufacturer's values may
not be correct. I discovered this with the Oxford detector on the
Sirion because the solid angle appeared to be lower than claimed.


- **If the material is in the database** (e.g. K240), type the name in the
element dialog and type control-enter and it will add all the lines.

- **The analytical simulation uses XPP** - the simplified model of
Pouchou (Ritchie pronounces as "Pooshoo") and Pichoir
(Ritchie pronounces as "Poushwar"). My French has always sounded
awful...

- **Simulations** Monte Carlo is more flexible. Knowing the density is more
critical for specimens that are not flat. 

- **Peak shape references**. All quantitative EDS measurements involve
comparing the intensity of the peak in the unknown to that from a
standard measured under (or corrected to) the same conditions. This
process usually involves spectrum fitting. The unknown specimen is fit
to spectra from the various elements from standard specimens. The 
composition of the unknown is determined from the results from those
fits.

    Consider an example of analysis of a complex glass, K-240, where we
    will focus on the elements Ba and Ti. In the region around 4.5 kVe Ba
    and Ti have a particularly nasty overlap. A good strategy in 
    quantitative analysis is to choose a standard similar in composition
    to what you expect for the unknown. This minimizes the magnitude of
    the matrix corrections and reduces the uncertainty of our results.
    
    In this case we choose Benitoite. The relative intensity in the
    region of interest is similar. The K-240 differs in that it has 
    additional Zr, Mg, and Zn.
    
    Benitoite has a problem as a standard for K-240: There is a
    significant overlap between Ba and Ti near 4.5 keV. To extract the
    information about Ba and Ti is challenging. We can fit a pure Ti
    spectrum and a pure Ba spectrum without other interferences in this
    region to the peak shape of our unknown. We can extract with good
    precision the intensities from Ba and Ti in this region. We might
    use a pure Ti sample and a sample of Sanbornite which is Ba silicate
    and does not contain Ti. We will treat Ti and Sanbornite as peak
    references. Reference spectra are only required if the standard has
    interferences.
    
    Use the Make Standard Bundle. Specify the material. For Benitoite,
    see [webmineral.com](http://webmineral.com/data/Benitoite.shtml#.W7Pw2BNKg_V).
    
    We start with this dialog
    
    ![](./png/build-std-bundle-standard.png)
    
    When we set reference spectrum, we need to **list all the elements** in the
    spectrum. Only the specified element will be highlighted when we start. We
    need to supply the rest by checking the box in the dialog.
    
    ![](./png/build-std-bundle-reference.png)
    
    We really only need to know the elements present in the reference. It is
    only being used for the **peak shape** information to fit the overlapped
    peaks in the unknown (and perhaps the standard as in this case).
    
    The software is looking for a "sufficient separation" of peaks so that 
    background regions can be defined. This requires a separation from other
    peaks of about one full width at half maximum on each side. We need to
    know the background to get the peak intensity. In DTSA-II's filter fit,
    this requires this 1 FWHM on each side to make a sufficiently precise
    measurement of the background. The **Standard Bundler** makes this easier
    for the user.
    
    After working through the K240 example from the Advanced Quant video, it
    seems that one should generate a standard bundle for each of the standards
    one will use and use those `.zstd` files for the quantification.

## Saving and reading spectra as XML

DTSA-II has a function to store and read spectra in `.xml` format
which stores much more metadata than the `.msa` format. We can do
this from the command line. After reading in (or simulating) a
spectrum, set the composition (if appropriate). Then go to the
command and list the spectra with

```
ls()
```

Spectra will be labeled `s1`, `s2`, ... Note the spectrum identifier 
associated with the spectrum you want to store as an XML file.
Save the file from the command line:

```
s2.toXML("/Users/jrminter/Desktop/Cu-2017-12-14-5eV-ch-2K.xml")
```

Read the spectrum from the command line with:

```
spc = spectrumFromXML("/Users/jrminter/Desktop/simulated-EagleXG.xml")
spc.display()
```

## X-ray transitions from the command line

1. Define a transition using the IUPAC name

    ```
    tra = transition('Si K-L3')
    ```

2. Print the Siegbahn name

   We print to render the unicode...

    ```
    print(tra.getSiegbahnName())
    Si Kα1
    ```
    Compare to IUPAC name
    
    ```
    print(tra.getIUPACName())
    Si K-L3
    ```
3. Get the relative weight

    ```
    tra.getWeight(0)
    1.0
    ```
    
    Compare to normalized
    
    ```
    tra.getWeight(1)
    0.6441638752898737
    ```
    
    Now compare to K-L2
    
    ```
    tra = transition('Si K-L2')
    tra.getWeight(0)
    0.505
    print(tra.getSiegbahnName())
    Si Kα2
    ```
    


## Using the **Simulation alien** to simulate individual spectrum components.

In general, I prefer to use a script to do simulations, but the
simulation alien has the ability to turn off/on different components.
Note the dialog below:

![Spectrum simulation options. Note how each type can be turned on or off (red arrows).](./png/simulation-alien-options.png)


![This figure was prepared by simulating Admiralty Brass with all
options on and then with single options turned on. This reproduces 
Goldstein2018a Fig. 17.37 p. 257.](./png/admiralty-brass-sim-15kV.png)

## Sources for free microanalysis software

DTSA-II is also included in
[this](http://probesoftware.com/smf/index.php?topic=927)
list from the Probe Software Forum!

## Energies for low energy L-l lines (L_II.III_) from light elements 

These are from Bearden (1967).

| Element | eV |
|:--------|---:|
| Na | 30.45 |
| Mg | 49.3 |
| Al | 72.4 |
| Si | 91.5 |
| P | 119.4 |
| S | 148.7 |

## For spectrum rename

| Symbol  | Description  |
|:--------|:-------------|
| \$I\$ | Index |
| \$ACQ\$ | Acquisition date and time |
| \$E0\$ | kV |
| \$I0\$ | probe current |
| \$CLIENT\$ | client |
| \$SPOT\$ | spot size | 
| \$DT\$ | dead time | 
| \$DET\$ | detector |  
| \$INST\$ | instrument | 
| \$OPER\$ | operator | 
| \$LT\$ | live time | 
| \$COMP\$ | composition | 
| \$OCR\$ | output count rate | 
| \$PA\$ | | 
| \$PROJ\$ | project | 
| \$PPS\$ | | 
| \$PPT\$ | | 
| \$RT\$ | | 
| \$RES\$ | resolution | 
| \$SHAPE\$ | shape | 
| \$MT\$ | | 
| \$SPEC\$ | specimen | 
| \$THICK\$ | thickness | 
| \$POS\$ | position | 
| \$PREV\$ | previous | 





## Database

see [vogella.com](http://www.vogella.com/tutorials/ApacheDerby/article.html)

see [apache.org](https://db.apache.org/derby/papers/DerbyTut/install_software.html)

Install derby.

On Windows, set environment variables

```
DERBY_INSTALL    C:\Apps\derby

CLASSPATH        %DERBY_INSTALL%\lib\derby.jar;%DERBY_INSTALL%\lib\derbytools.jar;.

JAVA_HOME        C:\Apps\Java64\jdk1.8.0_121

```

then start ij from a command prompt with:

```
java org.apache.derby.tools.ij
```


Use ij

```
connect 'jdbc:derby:/path/to/DTSA/Database v2/';

on Window

show schemas;
show tables in APP;
show indexes in app;

select * from APP.DETECTOR;





disconnect;
```

dump the schema

```
dump the schema

dblook -d 'jdbc:derby:/Users/jrminter/DTSA/Database v2/' -z APP -o dtsa2-db.sql
```

looks like

[ddlutils](http://db.apache.org/derby/integrate/db_ddlutils.html) can backup databases...

## Frequently needed scripts

### In OSImageAnalysis git repository

**In dtsa2/productionScripts directory:**

- JmGen.py is the workhorse.
- DumpMaterials.py and the **restore script** stds.py. Edit this last one to add new materials.
- listDetCalibrations.py to see what calibrations we have
- testGetMassFraction.py to aid adding new standards

## A proposed standard

Mark suggested I might be able to order this from
[Ted Pella](https://www.tedpella.com/calibration_html/UHV-EL_Reference_Standards_for_EDS_WDS.htm)
in Dec.

```
From Ted Pella

A standard
6075    UHV-EL 6 Rectangular Retainer, 9 x 12 mm,
        with 6 reference standards (select from list)  each    685.00  
or
6076    UHV-EL 9 Square Retainer, 13 x 12 mm,
        with 9 reference standards (select from list)  each    995.0

1. Faraday Cup, for beam current measurement, is available for all of the
   retainers and will take one of the spaces.
2. 146. Zinc Oxide  ZnO HP  ?
3. 102. Silicon Si  C   5N*
4.   1. Aluminum    Al  F   3N* or 
     3. Aluminum Oxide Al2O3 C 4N*
5.  30. Copper  Cu  F   2N or 
    31. Cupric Oxide    CuO P   3N
6.  89. Palladium   Pd  P   3N
7.  16. Boron Phosphide BP  P   3N
8. 108. Silver  Ag  F   3N5
9. 179. Rutile  TiO2

```

## Defining a custom material

It is important to add a name when one define a name when defining a
custom material that will be used with the MC3 simulations. Here is an
example for PET.
**Note that the mass fractions are useful for complex materials.**


```
pet = epq.Material(epq.Composition([epq.Element.C,epq.Element.H,epq.Element.O],
                                   [0.62502,0.04196,0.069042]),epq.ToSI.gPerCC(1.37))
pet.setName("PET")
```

or

```
k412 = epq.Material(epq.Composition([epq.Element.O,
                                     epq.Element.Mg,
                                     epq.Element.Al,
                                     epq.Element.Si,
                                     epq.Element.Ca,
                                     epq.Element.Fe],
                                    [ 0.4276,
                                      0.1166,
                                      0.0491,
                                      0.2120,
                                      0.1090,
                                      0.0774]
                                      ),
                                    epq.ToSI.gPerCC(2.600))
k412.setName("K412")

```


The final step is **really important** - sometime the simple approach produces Unicode characters in output file name generated automatically and these crash. **Simple names are better!!!**

**Get the mass fractions from the molecular formula the easy way:** 
I added a function to jmGen.py (v. 0.0.7) that wraps the utility functions in DTSA-II. The prototype is:

```
getMassFractions(compound, elemList, iDigits)
```

that one uses like this for an AZO compound with 2\% Al substituted for Zn:

```
import gov.nist.microanalysis.EPQLibrary as epq
import dtsa2.jmGen as jmg

elements = [epq.Element.Al, epq.Element.Zn, epq.Element.O]
massFra = jmg.getMassFractions("Al2Zn98O100", elements, 5)
```

which returns a dictionary with the mass fractions:

```
{'Al': 0.00669, 'O': 0.19841, 'Zn': 0.7949}
```



## File naming tricks

For simulations, I often name files with a **compound-kV-nTraj** type syntax. Writing a helper function can minimize repetition


```
def getSpecPath(baseName, baseDir, e0, nTraj):
    sName = "%s-%g-kV-%g-Traj" % (baseName, e0, nTraj)
    sPath = "%s/%s.msa" % (baseDir, sName)
    return sPath
```

I should also wrap a sequence like this:

```
spcFile = getSpecPath("Al", outDir, e0, nTraj)
al = wrap(readSpectrum(spcFile))
sp = spc.getProperties()
sp.setDetector(det)
al.display()
```

Here is my work-in-progress for a quantification script


```

ff = epq.FilterFit(det, epq.ToSI.keV(e0))
ff.addReference(element("Al"), al)
ff.addReference(element("Zn"), zno)
ff.addReference(element("O"), zno)
kr  = ff.getKRatios(azo)
kO  = kr.getKRatioU(epq.XRayTransition(epq.Element.O,epq.XRayTransition.KA1))
kZn = kr.getKRatioU(epq.XRayTransition(epq.Element.Zn,epq.XRayTransition.LA1))
kAl = kr.getKRatioU(epq.XRayTransition(epq.Element.Al,epq.XRayTransition.KA1))

fs = "%g\t%g\t%g\t%g\t%g\t%g" 

znoMat = epq.Material(epq.Composition([epq.Element.Zn,epq.Element.O],
                                      [0.80349,0.19651]),
                                      epq.ToSI.gPerCC(5.61))

stds = { epq.Element.Zn : znoMat, epq.Element.O : znoMat }

print (fs % (kO.doubleValue(), kO.uncertainty(),
             kZn.doubleValue(), kZn.uncertainty(),
             kAl.doubleValue(), kAl.uncertainty() ))


qr = quant(kr, 35.0, e0, stds, None, False, None, None)

print(qr)

print(dir(qr))

# print(qr.atomicPercentU(epq.Element.Al))
# print(qr.atomicPercentU(epq.Element.Zn))
# print(qr.atomicPercentU(epq.Element.O))

print(dir(qr.atomicPercentU(epq.Element.Al)))

# print(dir(epq.Element.Al))

def formatElement(qr, el):
    strLine  = "%s, " % el.toAbbrev()
    strLine += "%.6f, " % qr.atomicPercentU(el).doubleValue()
    strLine += "%.6f" % qr.atomicPercentU(el).uncertainty()
    return(strLine)

print("El, at.fra.mu, at.fra un")
out = formatElement(qr, epq.Element.Al)
print(out)
out = formatElement(qr, epq.Element.Zn)
print(out)
out = formatElement(qr, epq.Element.O)
print(out)


```


# System Administration

## Preferences

On Windows, preferences are stored in the registry. The base key is:

```
[HKEY_CURRENT_USER\Software\JavaSoft\Prefs\gov]
```
It is always useful to export this as a `.reg` file.

On MacOSX, preferences are stored in a `.plist` file...

```
~/Library/Preferences/gov.nist.microanalysis.plist
```
Edit this using XCode.

To force reloading from the cache file see [here](https://nethack.ch/2014/03/30/quick-tip-flush-os-x-mavericks-plist-file-cache/
), use the following from the terminal

```
defaults read gov.nist.microanalysis.plist
```


# Getting NISTMonte Monte Carlo packages to work with Iona and Jupiter

DTSA-II Iona seems to not export classes that were available
in Halley. I noticed that the `mcSimulate3.py` file had these
curious lines at the top:

```
import sys
sys.packageManager.makeJavaPackage("gov.nist.microanalysis.NISTMonte.Gen3", "CharacteristicXRayGeneration3, BremsstrahlungXRayGeneration3, FluorescenceXRayGeneration3, XRayTransport3", None)
```

Note: it does **not** like the lines to be split...

I did a Google search  and found
[this](http://sourceforge.net/p/jython/mailman/message/6725556/)
explanation: The following code works with Jython launched from the jar in the standard install:

```
import java.awt
f = java.awt.Frame()
f.title = "Hello AWT"
f.visible = True
```

but when run with `Jython.jar` from the standalone install
the code gives

```
>java -jar jython.jar
Jython 2.2b1 on java1.6.0 (JIT: null)
Type "copyright", "credits" or "license" for more information.
>>> import java.awt
Traceback (innermost last):
  File "", line 1, in ?
ImportError: no module named awt
>>> ^Z
```

WORKROUND

You need to nudge the system to do what caching would have done:-

```
import sys
sys.packageManager.makeJavaPackage("java.awt", "Window", None)
import java.awt
f = java.awt.Frame()
f.title = "Hello AWT"
f.visible = True
```

[Back to Index](../README.html)
